<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy Birch + FOV Menu</title>
<style>
  :root{--menu-size:60px;}
  html,body{height:100%; margin:0; background:#70c5ce; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  #gameWrap{position:relative; width:100%; height:100vh; overflow:hidden; display:flex; align-items:center; justify-content:center;}
  canvas{background:linear-gradient(#70c5ce,#4ec0d8); display:block; border:0; box-shadow:0 6px 20px rgba(0,0,0,0.2);}

  /* Floating circular draggable menu button */
  #menuButton{
    position:absolute;
    top:20px; left:20px;
    width:var(--menu-size); height:var(--menu-size);
    border-radius:50%;
    background:rgba(255,255,255,0.95);
    display:flex; align-items:center; justify-content:center;
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
    z-index:50;
    touch-action:none;
    user-select:none;
    cursor:grab;
    border:2px solid rgba(0,0,0,0.12);
  }
  #menuButton:active{cursor:grabbing;}
  #menuIcon{font-weight:700; font-size:20px;}

  /* menu content */
  #menuContent{
    position:absolute;
    top:calc(20px + var(--menu-size) + 10px);
    left:20px;
    width:220px;
    background:rgba(255,255,255,0.98);
    border-radius:10px;
    padding:10px;
    box-shadow:0 8px 30px rgba(0,0,0,0.18);
    display:none;
    z-index:49;
  }
  #menuContent h4{margin:0 0 8px 0; font-size:14px;}
  .row{display:flex; align-items:center; gap:8px; margin:6px 0;}
  label.switch{display:inline-flex; align-items:center; gap:8px; font-size:13px;}
  input[type=range]{width:100%;}

  button.small{
    padding:6px 8px; border-radius:6px; border:1px solid rgba(0,0,0,0.08);
    background:#fff; cursor:pointer; font-size:13px;
  }

  /* status panel top-right */
  #hud{
    position:absolute; top:10px; right:10px; z-index:40;
    background:rgba(255,255,255,0.9); padding:8px 10px; border-radius:8px;
    box-shadow:0 6px 18px rgba(0,0,0,0.12); font-size:13px;
  }

  /* small message */
  #message{
    position:absolute; left:50%; transform:translateX(-50%); top:18%;
    background:rgba(0,0,0,0.7); color:white; padding:8px 12px; border-radius:6px;
    display:none; z-index:60; font-weight:600;
  }

  /* responsive */
  @media (max-width:420px){ #menuContent{width:180px;} }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="canvas" width="360" height="640"></canvas>

  <div id="menuButton" title="Menu">
    <div id="menuIcon">≡</div>
  </div>

  <div id="menuContent" aria-hidden="true">
    <h4>Game Menu</h4>

    <div class="row">
      <label class="switch"><input id="fovToggle" type="checkbox"> Bật FOV</label>
    </div>

    <div class="row">
      <div style="flex:1">
        <label style="font-size:12px">FOV bán kính: <span id="fovVal">120</span>px</label>
        <input id="fovSlider" type="range" min="30" max="350" value="120">
      </div>
    </div>

    <div class="row" style="justify-content:space-between;">
      <button id="autoBtn" class="small">Auto: Off</button>
      <button id="infBtn" class="small">INF Tiền: Off</button>
      <button id="setLvBtn" class="small">Set Lv</button>
    </div>

    <div style="font-size:12px; margin-top:8px; color:#333;">
      <div>Hướng dẫn nhanh:</div>
      <ul style="padding-left:18px; margin:6px 0 0 0;">
        <li>FOV vẽ vòng tròn quanh chim và dò ống trong bán kính.</li>
        <li>Auto chơi: chim sẽ tự flap để né ống (thử bật).</li>
        <li>INF tiền: tiền sẽ tăng liên tục.</li>
      </ul>
    </div>
  </div>

  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Coins: <span id="coins">0</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>

  <div id="message">Ống gần kìa!</div>
</div>

<script>
// ----------------- Basic Flappy game implementation -----------------
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W = canvas.width, H = canvas.height;
function resizeCanvasToDisplaySize(){
  // keep fixed logical size for simplicity; could adapt to devicePixelRatio
}
resizeCanvasToDisplaySize();

// game state
let bird = { x:80, y:H/2, w:28, h:20, vel:0, gravity:0.6, lift:-10 };
let pipes = [];
let frame = 0;
let gap = 140;
let pipeSpeed = 2.2;
let spawnEvery = 90; // frames
let score = 0;
let coins = 0;
let level = 1;
let running = true;
let autoPlay = false;
let infMoney = false;

// FOV state
let fovOn = false;
let fovRadius = 120;
const message = document.getElementById('message');
let msgTimeout = null;

// HUD elements
const scoreEl = document.getElementById('score');
const coinsEl = document.getElementById('coins');
const levelEl = document.getElementById('level');
const fovToggle = document.getElementById('fovToggle');
const fovSlider = document.getElementById('fovSlider');
const fovVal = document.getElementById('fovVal');

// Input
canvas.addEventListener('pointerdown', () => {
  flap();
});
function flap(){ bird.vel = bird.lift; }

// pipes helpers
function spawnPipe(){
  const top = Math.random() * (H - gap - 120) + 40;
  pipes.push({ x: W + 20, top: top, width: 56, passed:false });
}

// simple collision
function collides(pipe){
  // pipe covers x..x+width, top..top+gap
  if (bird.x + bird.w > pipe.x && bird.x < pipe.x + pipe.width){
    if (bird.y < pipe.top || bird.y + bird.h > pipe.top + gap) return true;
  }
  return false;
}

// ----------------- Game loop -----------------
function update(){
  frame++;
  // spawn
  if (frame % spawnEvery === 0) spawnPipe();

  // bird physics
  bird.vel += bird.gravity;
  bird.y += bird.vel;
  // limit
  if (bird.y + bird.h > H){ bird.y = H - bird.h; bird.vel = 0; resetGame(); }
  if (bird.y < 0){ bird.y = 0; bird.vel = 0; }

  // pipes update
  for (let i = pipes.length-1; i >= 0; i--){
    let p = pipes[i];
    p.x -= pipeSpeed;
    // score when passed
    if (!p.passed && p.x + p.width < bird.x){
      p.passed = true; score++; scoreEl.textContent = score;
      coins += 1; coinsEl.textContent = coins;
    }
    // remove off-screen
    if (p.x + p.width < -40) pipes.splice(i,1);
    // collision
    if (collides(p)) { resetGame(); }
  }

  // Auto play simple AI
  if (autoPlay){
    // find next pipe
    let next = null;
    for (let p of pipes){
      if (p.x + p.width > bird.x - 10){ next = p; break; }
    }
    if (next){
      let gapY = next.top + gap/2;
      // if bird is below center of gap and approaching, flap
      if (bird.y > gapY - 10 && next.x < bird.x + 140) flap();
    }
  }

  // INF money
  if (infMoney){
    coins = Number.MAX_SAFE_INTEGER; coinsEl.textContent = "∞";
  }

  // FOV detection
  let nearFound = false;
  if (fovOn){
    for (let p of pipes){
      // compute closest point on pipe rect to bird center
      let bx = bird.x + bird.w/2, by = bird.y + bird.h/2;
      // check if pipe rect intersects circle of radius fovRadius
      // pipe rect ranges:
      let rx1 = p.x, rx2 = p.x + p.width;
      // top rect
      let ry1_top = 0, ry2_top = p.top;
      // bottom rect
      let ry1_bot = p.top + gap, ry2_bot = H;
      // helper to check circle-rect intersect
      function circleRectIntersect(cx,cy,r,rx1,ry1,rx2,ry2){
        // find closest point
        let closestX = Math.max(rx1, Math.min(cx, rx2));
        let closestY = Math.max(ry1, Math.min(cy, ry2));
        let dx = closestX - cx, dy = closestY - cy;
        return (dx*dx + dy*dy) <= r*r;
      }
      if (circleRectIntersect(bx,by,fovRadius, rx1,ry1_top, rx2,ry2_top) ||
          circleRectIntersect(bx,by,fovRadius, rx1,ry1_bot, rx2,ry2_bot)){
        nearFound = true;
        p._inFov = true;
      } else {
        p._inFov = false;
      }
    }
  } else {
    for (let p of pipes) p._inFov = false;
  }

  // show message if nearFound
  if (nearFound){
    showMessage("Ống gần kìa!");
  } else {
    hideMessage();
  }

  render();
  requestAnimationFrame(update);
}

function render(){
  // clear
  ctx.clearRect(0,0,W,H);

  // background simple sky already via CSS; draw ground
  ctx.fillStyle = "#ded895";
  ctx.fillRect(0, H - 80, W, 80);

  // pipes
  for (let p of pipes){
    // top pipe
    ctx.fillStyle = p._inFov ? "rgba(255,80,80,0.95)" : "#2e8b57";
    ctx.fillRect(p.x, 0, p.width, p.top);
    // bottom pipe
    ctx.fillStyle = p._inFov ? "rgba(255,80,80,0.95)" : "#2e8b57";
    ctx.fillRect(p.x, p.top + gap, p.width, H - (p.top + gap) - 80);
    // pipe caps (rounded look)
    ctx.fillStyle = p._inFov ? "rgba(200,60,60,0.95)" : "#246b45";
    ctx.fillRect(p.x - 4, p.top - 12, p.width + 8, 12);
    ctx.fillRect(p.x - 4, p.top + gap, p.width + 8, 12);
  }

  // bird
  ctx.fillStyle = "#ffdd57";
  ctx.fillRect(bird.x, bird.y, bird.w, bird.h);
  // simple eye
  ctx.fillStyle = "#000";
  ctx.fillRect(bird.x + bird.w - 8, bird.y + 6, 4, 4);

  // draw FOV circle around bird
  if (fovOn){
    ctx.beginPath();
    ctx.arc(bird.x + bird.w/2, bird.y + bird.h/2, fovRadius, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.stroke();
    ctx.setLineDash([]);
    // subtle fill
    ctx.fillStyle = "rgba(0,200,80,0.06)";
    ctx.beginPath();
    ctx.arc(bird.x + bird.w/2, bird.y + bird.h/2, fovRadius, 0, Math.PI*2);
    ctx.fill();
  }

  // draw score text
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score, 12, 28);
}

function resetGame(){
  // simple reset: keep coins/level, reset bird and pipes, optionally not zero coins if infMoney
  bird.y = H/2; bird.vel = 0;
  pipes = [];
  frame = 0;
  score = 0;
  scoreEl.textContent = score;
  if (!infMoney){ coins = 0; coinsEl.textContent = coins; }
}

// ----------------- Message helpers -----------------
function showMessage(txt){
  if (msgTimeout) clearTimeout(msgTimeout);
  message.textContent = txt;
  message.style.display = 'block';
  // auto-hide after 1200ms if not continuously triggered
  msgTimeout = setTimeout(()=>{ message.style.display = 'none'; msgTimeout = null; }, 1200);
}
function hideMessage(){ if (!msgTimeout) message.style.display='none'; }

// ----------------- Menu interactions -----------------
const menuButton = document.getElementById('menuButton');
const menuContent = document.getElementById('menuContent');

let dragging = false, dx=0, dy=0, startX=0, startY=0, startLeft=0, startTop=0, movedDuringPointer=false;

menuButton.addEventListener('pointerdown', (ev)=>{
  ev.preventDefault();
  dragging = true; movedDuringPointer=false;
  startX = ev.clientX; startY = ev.clientY;
  const rect = menuButton.getBoundingClientRect();
  startLeft = rect.left; startTop = rect.top;
  menuButton.setPointerCapture(ev.pointerId);
});
document.addEventListener('pointermove', (ev)=>{
  if (!dragging) return;
  let nx = startLeft + (ev.clientX - startX);
  let ny = startTop + (ev.clientY - startY);
  // clamp inside viewport
  nx = Math.max(6, Math.min(window.innerWidth - rectSize() - 6, nx));
  ny = Math.max(6, Math.min(window.innerHeight - rectSize() - 6, ny));
  menuButton.style.left = nx + 'px';
  menuButton.style.top = ny + 'px';
  movedDuringPointer = true;
});
document.addEventListener('pointerup', (ev)=>{
  if (!dragging) return;
  dragging = false;
  try{ menuButton.releasePointerCapture(ev.pointerId); }catch(e){}
  // small delay before treating as click
  if (!movedDuringPointer){
    toggleMenu();
  }
});

function rectSize(){ return parseInt(getComputedStyle(menuButton).width); }
function toggleMenu(){
  if (menuContent.style.display === 'block'){ menuContent.style.display='none'; menuContent.setAttribute('aria-hidden','true'); }
  else { 
    // position menuContent near button
    const r = menuButton.getBoundingClientRect();
    menuContent.style.left = r.left + 'px';
    menuContent.style.top = (r.top + rectSize() + 10) + 'px';
    menuContent.style.display = 'block'; menuContent.setAttribute('aria-hidden','false');
  }
}

// menu controls
fovToggle.addEventListener('change', (e)=>{
  fovOn = e.target.checked;
});
fovSlider.addEventListener('input', (e)=>{
  fovRadius = Number(e.target.value);
  fovVal.textContent = fovRadius;
});

const autoBtn = document.getElementById('autoBtn');
autoBtn.addEventListener('click', ()=>{
  autoPlay = !autoPlay; autoBtn.textContent = 'Auto: ' + (autoPlay ? 'On' : 'Off');
});

const infBtn = document.getElementById('infBtn');
infBtn.addEventListener('click', ()=>{
  infMoney = !infMoney; infBtn.textContent = 'INF Tiền: ' + (infMoney ? 'On' : 'Off');
  if (infMoney){ coinsEl.textContent = "∞"; } else { coins = 0; coinsEl.textContent = coins; }
});

const setLvBtn = document.getElementById('setLvBtn');
setLvBtn.addEventListener('click', ()=>{
  let val = prompt("Nhập level mong muốn (số nguyên >=1):", String(level));
  if (val !== null){
    let n = parseInt(val);
    if (!isNaN(n) && n >= 1){
      level = n; levelEl.textContent = level;
      showMessage('Level set: ' + level);
    } else {
      alert('Giá trị không hợp lệ.');
    }
  }
});

// basic responsiveness: scale canvas to fit smaller screens
function adaptCanvas(){
  const vw = Math.min(window.innerWidth, 420);
  const scale = vw / 360;
  canvas.style.width = (360 * scale) + 'px';
  canvas.style.height = (640 * scale) + 'px';
}
window.addEventListener('resize', adaptCanvas);
adaptCanvas();

// start game
spawnPipe();
spawnPipe();
requestAnimationFrame(update);

</script>
</body>
</html>
