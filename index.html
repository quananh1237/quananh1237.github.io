<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Flappy Birch — Multiplayer (Firebase)</title>
<style>
  *{box-sizing:border-box;font-family:system-ui,Arial;}
  body,html{height:100%;margin:0;background:#87ceeb;touch-action:manipulation;user-select:none;}
  .wrap{max-width:920px;margin:12px auto;padding:12px;}
  .card{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.12);}
  .row{display:flex;gap:8px;}
  input,select,button{padding:10px;border-radius:8px;border:1px solid #ccc;}
  button{background:#046;color:#fff;border:0;font-weight:700;}
  #gameArea{margin-top:12px;position:relative;}
  canvas{width:100%;height:520px;display:block;border-radius:8px;background:linear-gradient(#87ceeb,#5cc1ff);pointer-events:auto;}
  #overlayUI{position:absolute;left:8px;top:8px;color:#000;}
  .chip{display:inline-block;background:rgba(255,255,255,0.9);padding:6px 8px;border-radius:999px;margin-right:6px;font-weight:700;}
  #deathOverlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:20;}
  #deathBox{background:#fff;padding:16px;border-radius:10px;text-align:center;}
  #playersList{margin-top:8px;}
  .small{font-size:13px;color:#333;margin-top:6px;}
  footer{margin-top:12px;text-align:center;color:#fff;}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <h3 style="margin:0">Flappy Birch — Multiplayer</h3>
      <div class="small">Creator name (host) mặc định: <strong>Bindz</strong></div>
    </div>

    <div style="margin-top:8px" class="row">
      <input id="nameInput" placeholder="Tên (mặc định Bindz nếu bạn tạo phòng)" />
      <select id="modeSelect">
        <option value="shared">Shared (xem chim nhau)</option>
        <option value="solo">Solo (chỉ gửi score)</option>
      </select>
      <button id="btnCreate">Create Room</button>
      <input id="joinCode" placeholder="Nhập mã phòng (6 ký tự)" style="width:160px"/>
      <button id="btnJoin" class="">Join</button>
    </div>

    <div class="small">
      <span id="roomInfo"></span>
    </div>

    <div id="playersList" class="small"></div>
  </div>

  <div id="gameArea" class="card" style="margin-top:12px;overflow:hidden;">
    <div id="overlayUI">
      <span class="chip" id="roomChip">Room: -</span>
      <span class="chip" id="meChip">You: -</span>
      <span class="chip" id="scoreChip">Score: 0</span>
    </div>
    <canvas id="c" width="900" height="520"></canvas>

    <div id="deathOverlay"><div id="deathBox">
      <h3>BẠN ĐÃ CHẾT</h3>
      <div style="margin:8px 0"><button id="btnReset">Reset</button></div>
    </div></div>
  </div>

  <footer class="small">Chạy trên điện thoại: chạm để flap. Mỗi người 1 con chim. Khi chết, chim dừng (chỉ hồi khi nhấn Reset).</footer>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
/* ========== CẤU HÌNH FIREBASE ========== 
  Tạo project Firebase, bật Realtime Database (test mode là nhanh).
  Thay object firebaseConfig dưới đây bằng config của bạn.
*/
const firebaseConfig = {
  apiKey: "REPLACE_API_KEY",
  authDomain: "REPLACE_PROJECT.firebaseapp.com",
  databaseURL: "https://REPLACE_PROJECT-default-rtdb.firebaseio.com",
  projectId: "REPLACE_PROJECT",
  storageBucket: "REPLACE_PROJECT.appspot.com",
  messagingSenderId: "REPLACE_ID",
  appId: "REPLACE_APPID"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ========== UI ========== */
const nameInput = document.getElementById('nameInput');
const btnCreate = document.getElementById('btnCreate');
const btnJoin = document.getElementById('btnJoin');
const joinCode = document.getElementById('joinCode');
const roomInfo = document.getElementById('roomInfo');
const playersList = document.getElementById('playersList');
const c = document.getElementById('c');
const ctx = c.getContext('2d');
const roomChip = document.getElementById('roomChip');
const meChip = document.getElementById('meChip');
const scoreChip = document.getElementById('scoreChip');
const deathOverlay = document.getElementById('deathOverlay');
const btnReset = document.getElementById('btnReset');
const modeSelect = document.getElementById('modeSelect');

nameInput.value = '';
let myName = '';
let roomId = null;
let isHost = false;
let mode = 'shared'; // shared or solo
let playerId = null;

/* ========== Game state ========== */
let W = c.width, H = c.height;
let pipes = []; // host authoritative
let pipeTimer = 0;
let gravity = 0.45, flapPower = -8;
let gameRunning = false;
let localBird = null;
let players = {}; // id -> bird object {x,y,vy,name,alive,score,color}
let syncTimer = null;
let hostListener = null;
let playersListener = null;
let pipesListener = null;

/* ========== Helpers ========== */
function uid(){ return 'p'+Math.random().toString(36).slice(2,9); }
function genRoom(){ return Math.random().toString(36).slice(2,8).toUpperCase(); }
function colorRand(){ return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0'); }

/* ========== Bird class ========== */
function makeBird(id,name,color){
  return {id:id, name:name || 'Player', x:150, y:H/2, vy:0, w:34, h:24, color: color||colorRand(), alive:true, score:0, passed:-1};
}

/* ========== Render ========== */
function renderAll(){
  ctx.clearRect(0,0,W,H);
  // ground
  ctx.fillStyle = '#6b3';
  ctx.fillRect(0,H-50,W,50);
  // pipes
  for(const p of pipes){
    ctx.fillStyle = '#2b8';
    ctx.fillRect(p.x,0,52,p.top);
    ctx.fillRect(p.x,p.top+p.gap,52,H-(p.top+p.gap)-50);
  }
  // players
  for(const id in players){
    const b = players[id];
    if(!b) continue;
    // draw bird
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.ellipse(b.x,b.y,b.w/2,b.h/2,0,0,Math.PI*2);
    ctx.fill();
    // eye
    ctx.fillStyle='#000';
    ctx.fillRect(b.x+6,b.y-4,4,4);
    // name
    ctx.fillStyle='#000';
    ctx.textAlign='center';
    ctx.font='14px system-ui';
    ctx.fillText(b.name, b.x, b.y-28);
    // score overlay top-left one per player (only show top-left player's score as global)
  }
}

/* ========== Pipes management (host only) ========== */
function spawnPipe(){ pipes.push({x:W+40, top: Math.floor(Math.random()*(H-200-140))+60, gap:140}); }
function updatePipes(){
  for(const p of pipes) p.x -= 2.6;
  if(pipes.length && pipes[0].x < -80) pipes.shift();
}

/* ========== Physics update ========== */
function updatePhysics(){
  if(!gameRunning) return;
  // host updates pipes
  if(isHost && mode === 'shared'){
    pipeTimer++;
    if(pipeTimer>110){ spawnPipe(); pipeTimer=0; db.ref('rooms/'+roomId+'/pipes').set(pipes); }
  }
  updatePipes();
  // update each bird
  for(const id in players){
    const b = players[id];
    if(!b.alive) continue;
    b.vy += gravity;
    b.y += b.vy;
    if(b.y + b.h/2 >= H-50){ b.alive=false; onDeath(id); }
    if(b.y - b.h/2 <= 0){ b.y = b.h/2; b.vy = 0; }
    // collision with pipes
    for(const p of pipes){
      if(b.x + b.w/2 > p.x && b.x - b.w/2 < p.x + 52){
        if(b.y - b.h/2 < p.top || b.y + b.h/2 > p.top + p.gap){
          b.alive = false;
          onDeath(id);
        }
      } else {
        // scoring: when bird passes pipe's trailing edge
        if(b.passed < pipes.indexOf(p) && b.x > p.x + 52){
          b.passed = pipes.indexOf(p);
          b.score = (b.score||0) + 1;
          if(isHost && mode==='shared'){
            // update player score in DB
            db.ref('rooms/'+roomId+'/players/'+id+'/score').set(b.score);
          }
          if(id === playerId){
            scoreChip.textContent = 'Score: ' + b.score;
          }
        }
      }
    }
  }
  // host write players positions periodically
  if(isHost && mode==='shared'){
    db.ref('rooms/'+roomId+'/players').set(players);
  }
  renderAll();
}

/* ========== Death/reset handling ========== */
function onDeath(id){
  // notify DB for solo/shared (only update players alive flag)
  if(mode==='shared'){
    db.ref('rooms/'+roomId+'/players/'+id+'/alive').set(false);
  }
  if(id === playerId){
    deathOverlay.style.display = 'flex';
  }
}

/* reset local player */
function resetLocal(){
  if(!players[playerId]) return;
  players[playerId].y = H/2; players[playerId].vy = 0; players[playerId].alive = true; players[playerId].score = 0; players[playerId].passed = -1;
  scoreChip.textContent = 'Score: 0';
  deathOverlay.style.display = 'none';
  // write to DB
  if(mode==='shared') db.ref('rooms/'+roomId+'/players/'+playerId).set(players[playerId]);
  if(mode==='solo') {
    // just local
  }
}

/* ========== Input (flap) ========== */
function flapLocal(){
  if(!players[playerId] || !players[playerId].alive) return;
  players[playerId].vy = flapPower;
  // if shared and not host, write small update
  if(mode==='shared' && !isHost){
    db.ref('rooms/'+roomId+'/players/'+playerId+'/y').set(players[playerId].y);
    db.ref('rooms/'+roomId+'/players/'+playerId+'/vy').set(players[playerId].vy);
  }
}
window.addEventListener('keydown', e => { if(e.code==='Space') flapLocal(); });
c.addEventListener('touchstart', e => { e.preventDefault(); flapLocal(); }, {passive:false});
c.addEventListener('mousedown', e => { flapLocal(); });

/* ========== Networking: create/join room ========== */
btnCreate.addEventListener('click', async () => {
  myName = (nameInput.value||'').trim() || 'Bindz';
  mode = modeSelect.value;
  playerId = uid();
  isHost = true;
  roomId = genRoom(); // short code easy to type
  roomInfo.textContent = 'Đã tạo phòng: ' + roomId + ' (host)';
  roomChip.textContent = 'Room: ' + roomId;
  meChip.textContent = 'You: ' + myName + ' (Host)';
  // create initial room in DB
  const roomRef = db.ref('rooms/'+roomId);
  const initial = {mode: mode, pipes: [], host: playerId, createdAt: Date.now()};
  await roomRef.set(initial);
  // add host player
  players = {};
  players[playerId] = makeBird(playerId, myName, colorRand());
  await roomRef.child('players/'+playerId).set(players[playerId]);
  // listen for players changes
  attachRoomListeners();
  // host will control authoritative pipes; start game only when host presses start (we use Start immediate for simplicity)
  startAsHost();
});

btnJoin.addEventListener('click', async () => {
  const code = (joinCode.value||'').trim().toUpperCase();
  if(!code){ alert('Nhập mã phòng (6 ký tự).'); return; }
  const roomRef = db.ref('rooms/'+code);
  const snap = await roomRef.get();
  if(!snap.exists()){ alert('Phòng không tồn tại hoặc đã đóng. Kiểm tra lại mã.'); return; }
  const meta = snap.val();
  mode = meta.mode || 'shared';
  // join
  myName = (nameInput.value||'').trim() || ('Player'+Math.floor(Math.random()*99));
  playerId = uid();
  roomId = code;
  isHost = false;
  roomChip.textContent = 'Room: ' + roomId;
  meChip.textContent = 'You: ' + myName;
  // add self to DB players
  const myBird = makeBird(playerId, myName, colorRand());
  await db.ref('rooms/'+roomId+'/players/'+playerId).set(myBird);
  // attach listeners to read pipes/players/start
  attachRoomListeners();
  // if solo mode, we don't need to wait; start local game
  if(mode==='solo'){ startSolo(); }
});

/* attach listeners for room updates (players & pipes) */
function attachRoomListeners(){
  if(playersListener) playersListener.off();
  if(pipesListener) pipesListener.off();
  const playersRef = db.ref('rooms/'+roomId+'/players');
  playersListener = playersRef.on('value', snapshot => {
    const data = snapshot.val() || {};
    // merge into local players (keep local alive)
    for(const id in data){
      const p = data[id];
      if(!players[id]) players[id] = makeBird(id,p.name,p.color||colorRand());
      // update fields from DB (but if local and moving, we keep local pos)
      players[id].name = p.name;
      players[id].score = p.score || 0;
      players[id].alive = (p.alive === undefined) ? players[id].alive : p.alive;
      players[id].color = p.color || players[id].color;
      if(!isHost && id !== playerId){
        players[id].x = p.x || players[id].x;
        players[id].y = p.y || players[id].y;
        players[id].vy = p.vy || players[id].vy;
      }
    }
    // remove any players not in DB
    for(const id in players){
      if(!data[id]) delete players[id];
    }
    renderPlayersList();
  });

  const pipesRef = db.ref('rooms/'+roomId+'/pipes');
  pipesListener = pipesRef.on('value', snap => {
    pipes = snap.val() || [];
  });
}

/* Host starts game authoritative */
function startAsHost(){
  gameRunning = true;
  // host runs pipes and physics and writes players & pipes to DB
  if(syncTimer) clearInterval(syncTimer);
  syncTimer = setInterval(()=> {
    updatePhysics();
    // host writes players positions and pipes (already in updatePhysics writes pipes occasionally)
    db.ref('rooms/'+roomId+'/players').set(players);
    db.ref('rooms/'+roomId+'/pipes').set(pipes);
  }, 1000/60);
  // also start render loop if not already
  requestAnimationFrame(loopRender);
}

/* Solo mode start */
function startSolo(){
  gameRunning = true;
  // create local bird
  if(!players[playerId]) players[playerId] = makeBird(playerId,myName,colorRand());
  localBird = players[playerId];
  if(syncTimer) clearInterval(syncTimer);
  syncTimer = setInterval(()=> {
    updatePhysics(); // local only
  }, 1000/60);
  requestAnimationFrame(loopRender);
}

/* render loop */
function loopRender(){ renderAll(); if(gameRunning) requestAnimationFrame(loopRender); }

/* render players list UI */
function renderPlayersList(){
  playersList.innerHTML = '';
  for(const id in players){
    const p = players[id];
    const el = document.createElement('div');
    el.textContent = p.name + (id===playerId ? ' (You)' : '') + ' — score: ' + (p.score||0) + (p.alive ? '' : ' (dead)');
    playersList.appendChild(el);
  }
}

/* Reset button local */
btnReset.addEventListener('click', async ()=> {
  resetLocal();
  // write to DB
  if(mode==='shared') await db.ref('rooms/'+roomId+'/players/'+playerId).set(players[playerId]);
});

/* leave room on unload */
window.addEventListener('beforeunload', ()=> {
  if(roomId && playerId){
    try{ db.ref('rooms/'+roomId+'/players/'+playerId).remove(); }catch(e){}
  }
});

/* start a minimal loop even if not host to update local player pos in DB periodically for other clients */
setInterval(()=> {
  if(mode==='shared' && !isHost && roomId && players[playerId]){
    db.ref('rooms/'+roomId+'/players/'+playerId+'/y').set(players[playerId].y);
    db.ref('rooms/'+roomId+'/players/'+playerId+'/x').set(players[playerId].x);
    db.ref('rooms/'+roomId+'/players/'+playerId+'/vy').set(players[playerId].vy);
  }
}, 200);

/* Start rendering baseline */
requestAnimationFrame(loopRender);

/* If user wants quick test without firebase config set, provide simple single-player fallback */
if(firebaseConfig.apiKey.includes('REPLACE')){
  roomInfo.textContent = 'Chú ý: Bạn chưa thay Firebase config. Thêm config vào file để bật multiplayer. (Hoặc để test: paste config từ Firebase project của bạn.)';
}

</script>
</body>
</html>
