<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Flappy Birch Multiplayer (Lobby & Room)</title>
<!-- ngăn pinch/zoom trên iOS/Android -->
<style>
  html,body{height:100%;margin:0;background:#87ceeb;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  #container{display:flex;flex-direction:column;height:100%;}
  header{padding:12px;background:#046; color:#fff; display:flex;align-items:center;justify-content:space-between;}
  header h1{font-size:16px;margin:0;}
  main{flex:1;display:flex;align-items:center;justify-content:center;position:relative;padding:12px;}
  .panel{width:420px;max-width:100%;background:rgba(255,255,255,0.95);border-radius:10px;padding:14px;box-shadow:0 6px 20px rgba(0,0,0,0.15);}
  label{display:block;margin-top:8px;font-size:13px;color:#333;}
  input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #ccc;box-sizing:border-box;}
  .row{display:flex;gap:8px;margin-top:8px;}
  button{flex:1;padding:10px;border-radius:8px;border:0;background:#046;color:#fff;font-weight:600;}
  button.secondary{background:#888;}
  #lobbyPlayers{margin-top:10px;font-size:13px;}
  #canvasWrap{width:100%;height:520px;max-height:70vh;background:linear-gradient(#87ceeb,#5cc1ff);border-radius:10px;overflow:hidden;position:relative;}
  canvas{display:block;width:100%;height:100%;}
  #overlay{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;pointer-events:none;}
  .modal{background:rgba(255,255,255,0.98);padding:18px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.2);pointer-events:auto;}
  #playersList{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
  .playerChip{background:#eef;border-radius:999px;padding:6px 10px;font-size:13px;}
  .small{font-size:12px;color:#444;margin-top:6px;}
  /* overlay death */
  #deathScreen{position:absolute;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;z-index:30;background:rgba(0,0,0,0.5);}
  #deathScreen .modal{text-align:center;}
  /* names above birds */
  .nameTag{position:absolute;transform:translateX(-50%);font-weight:700;text-shadow:0 1px 2px rgba(0,0,0,0.6);}
  /* prevent zoom via gestures */
  body,html,canvas{touch-action:manipulation; -webkit-user-select:none; user-select:none;}
  footer{padding:8px;text-align:center;font-size:12px;color:#fff;background:#034;}
</style>
</head>
<body>
<div id="container">
  <header>
    <h1>Flappy Birch — Multiplayer (Lobby bằng mã)</h1>
    <div id="statusSmall">Disconnected</div>
  </header>

  <main>
    <div class="panel" id="lobbyPanel">
      <div style="display:flex;gap:8px;align-items:center;">
        <input id="playerName" type="text" placeholder="Tên bạn (ví dụ: Quân)" />
        <button id="btnCreate">Create code</button>
      </div>

      <label>Hoặc nhập mã phòng để Join</label>
      <div class="row">
        <input id="roomInput" type="text" placeholder="Nhập mã phòng (6 ký tự)" />
        <button id="btnJoin" class="secondary">Join</button>
      </div>

      <div id="lobbyInfo" class="small">
        <div id="myRoomArea" style="display:none;margin-top:8px;">
          <div>Mã phòng (chia sẻ cho bạn bè): <strong id="myRoomCode"></strong></div>
          <div class="small">Bạn là host — khi sẵn sàng nhấn <strong>Start</strong>.</div>
          <div style="margin-top:8px;">
            <button id="btnStart">Start</button>
            <button id="btnCloseRoom" class="secondary">Close Room</button>
          </div>
        </div>

        <div id="joinedRoomArea" style="display:none;margin-top:8px;">
          <div>Bạn đã gia nhập phòng: <strong id="joinedRoomCode"></strong></div>
          <div class="small">Chờ host bấm Start...</div>
        </div>

        <div id="lobbyPlayers" style="display:none;">
          <div>Người trong phòng:</div>
          <div id="playersList"></div>
        </div>
      </div>

      <div class="small" style="margin-top:10px;">
        Lưu ý: Kết nối P2P dùng PeerJS (signaling công cộng). Thử nghiệm trên cùng Wi-Fi / mobile data sẽ OK. Nếu không kết nối được, thử reload cả 2 thiết bị.
      </div>
    </div>

    <div id="canvasWrap" style="display:none;">
      <div id="overlay"></div>
      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <div id="deathScreen">
        <div class="modal">
          <h2 style="margin:0 0 10px 0;color:#fff">Bạn đã chết</h2>
          <button id="btnReset">Reset & Play Again</button>
        </div>
      </div>
    </div>
  </main>

  <footer>Hoàn thiện cơ bản — bạn có thể dùng code này làm nền để mở rộng.</footer>
</div>

<!-- PeerJS CDN -->
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

<script>
/*
  Flappy Birch Multiplayer (single-file)
  - Lobby: create/join room code (room code = hostPeerIdShort)
  - Host: listens for peers, displays players in lobby
  - Joiner: connects to host; sends name
  - Start: host sends 'start' to all; game begins
  - Simple P2P sync: players send position/velocity periodically
  - On death: show reset overlay for that player; reset restarts only that player
  - Note: relies on PeerJS cloud signaling; for production use add your own signaling or server.
*/

/* ---------- Helpers ---------- */
const $ = id => document.getElementById(id);
const randId = (len=6) => Math.random().toString(36).slice(2,2+len).toUpperCase();

/* ---------- UI elements ---------- */
const btnCreate = $('btnCreate');
const btnJoin = $('btnJoin');
const btnStart = $('btnStart');
const btnCloseRoom = $('btnCloseRoom');
const btnReset = $('btnReset');
const roomInput = $('roomInput');
const playerNameInput = $('playerName');
const myRoomArea = $('myRoomArea');
const joinedRoomArea = $('joinedRoomArea');
const myRoomCodeEl = $('myRoomCode');
const joinedRoomCodeEl = $('joinedRoomCode');
const playersListEl = $('playersList');
const lobbyPlayers = $('lobbyPlayers');
const lobbyPanel = $('lobbyPanel');
const canvasWrap = $('canvasWrap');
const overlay = $('overlay');
const statusSmall = $('statusSmall');
const deathScreen = $('deathScreen');

/* ---------- Peer & room state ---------- */
let peer = null;
let isHost = false;
let roomCode = null;      // short code shown to users (host's peer id short)
let hostPeerId = null;    // full peer id of host (for joining)
let connections = {};     // peerId -> DataConnection (only on host)
let connectionsReverse = {}; // for joiners: store conn to host
let players = {};         // peerId -> {name, x,y,...,alive}
let myPeerId = null;
let myPlayerName = '';

/* ---------- Game variables ---------- */
const canvas = $('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
let gameStarted = false;
let localBird = null; // our bird
let pipes = [];
let pipeTimer = 0;
let gravity = 0.4;
let flapPower = -7.5;
let tickInterval = null;
let syncInterval = null;

/* ---------- Bird class ---------- */
class Bird {
  constructor(id, name, color){
    this.id = id;
    this.name = name;
    this.x = 150;
    this.y = H/2;
    this.vy = 0;
    this.width = 34;
    this.height = 24;
    this.color = color || '#ff0';
    this.alive = true;
    this.score = 0;
  }
  flap(){ if(!this.alive) return; this.vy = flapPower; }
  update(){
    if(!this.alive) return;
    this.vy += gravity;
    this.y += this.vy;
    // collision with ground/ceiling
    if(this.y + this.height/2 >= H - 50){ this.alive=false; onDeath(this.id); }
    if(this.y - this.height/2 <= 0){ this.y = this.height/2; this.vy = 0; }
  }
  draw(ctx){
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, this.width/2, this.height/2, 0, 0, Math.PI*2);
    ctx.fill();
    // eyes
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x+6, this.y-4, 4,4);
  }
}

/* ---------- Pipes ---------- */
function spawnPipe(){
  const gap = 140;
  const top = Math.random()*(H - 200 - gap) + 60;
  pipes.push({x:W+40, top: top, gap: gap});
}

function updatePipes(){
  for(let p of pipes) p.x -= 2.6;
  if(pipes.length && pipes[0].x < -80) pipes.shift();
  // collision check for each bird
  for(const id in players){
    const b = players[id];
    if(!b.alive) continue;
    for(const p of pipes){
      if(b.x + b.width/2 > p.x && b.x - b.width/2 < p.x + 52){
        if(b.y - b.height/2 < p.top || b.y + b.height/2 > p.top + p.gap){
          b.alive = false;
          onDeath(id);
        }
      } else {
        // passing successfully increases score when crossing pipe's x coordinate (approx)
        if(!b._passed && b.x > p.x + 52){
          b._passed = true;
          b.score = (b.score||0)+1;
        }
      }
    }
  }
}

/* ---------- Rendering ---------- */
function render(){
  // background
  ctx.clearRect(0,0,W,H);
  // sky gradient done via CSS background; draw ground
  ctx.fillStyle = '#6b3';
  ctx.fillRect(0,H-50,W,50);

  // pipes
  for(const p of pipes){
    ctx.fillStyle = '#2b8';
    // top
    ctx.fillRect(p.x, 0, 52, p.top);
    // bottom
    ctx.fillRect(p.x, p.top + p.gap, 52, H - (p.top + p.gap) - 50);
  }

  // players
  for(const id in players){
    const p = players[id];
    if(!p) continue;
    p.draw(ctx);
    // draw name
    ctx.font = '14px system-ui';
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.fillText(p.name, p.x, p.y - 28);
    // score
    ctx.fillText('Score: ' + (p.score||0), p.x, 20);
  }
}

/* ---------- Game loop ---------- */
function gameTick(){
  if(!gameStarted) return;
  // spawn pipes
  pipeTimer++;
  if(pipeTimer > 120){
    spawnPipe();
    pipeTimer = 0;
  }
  // update each bird
  for(const id in players) players[id].update();
  updatePipes();
  render();
}

/* ---------- Start / Reset ---------- */
function startGame(){
  // initialize pipes & birds
  pipes = [];
  pipeTimer = 0;
  gameStarted = true;
  // create local bird for myself if not exist
  if(!players[myPeerId]){
    // color random
    const color = '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
    players[myPeerId] = new Bird(myPeerId, myPlayerName || 'You', color);
  } else {
    players[myPeerId].y = H/2; players[myPeerId].vy = 0; players[myPeerId].alive = true; players[myPeerId].score = 0;
  }
  localBird = players[myPeerId];
  // reset others' states back to alive
  for(const id in players){
    if(id !== myPeerId){
      players[id].alive = true;
      players[id].score = players[id].score || 0;
    }
  }
  // start tick if not running
  if(!tickInterval) tickInterval = setInterval(gameTick, 1000/60);
  // start syncing
  if(!syncInterval) syncInterval = setInterval(sendSync, 120);
  // show canvasWrap
  lobbyPanel.style.display = 'none';
  canvasWrap.style.display = 'block';
  deathScreen.style.display = 'none';
}

/* reset only local player */
function resetLocal(){
  if(players[myPeerId]){
    players[myPeerId].y = H/2;
    players[myPeerId].vy = 0;
    players[myPeerId].alive = true;
    players[myPeerId].score = 0;
  }
  deathScreen.style.display = 'none';
  // notify others to reset this player
  messageAll({type:'reset-player', id: myPeerId});
}

/* when any player dies */
function onDeath(peerId){
  // notify others about death so they can show that bird dead
  messageAll({type:'death', id: peerId});
  if(peerId === myPeerId){
    deathScreen.style.display = 'flex';
  }
}

/* ---------- Networking: PeerJS logic ---------- */

/* create host */
async function createRoom(){
  cleanupPeer();
  isHost = true;
  peer = new Peer(undefined, { // use PeerJS default cloud
    host: '0.peerjs.com', // PeerJS defaults often work via unpkg client; leaving config to defaults is acceptable
    secure: true,
    port: 443,
    debug: 2
  });
  attachPeerEvents();
}

/* join as client to hostPeerId (full id or short code=roomCode) */
async function joinRoom(codeOrId){
  cleanupPeer();
  isHost = false;
  peer = new Peer(undefined, {secure:true, debug:2});
  attachPeerEvents();
  // once open, connect to host
  peer.on('open', () => {
    myPeerId = peer.id;
    statusSmall.innerText = 'Joined network as ' + short(myPeerId);
    // if code is short (6 chars) treat as host short id: assume host's id contains that as suffix -> try to auto match
    // We'll attempt to connect to any peer whose id contains the code (best-effort)
    const target = codeOrId;
    // connect directly to the room code as host id (we expect host to share full id or short id)
    console.log('Trying to connect to host:', target);
    const conn = peer.connect(target, {metadata:{name: myPlayerName}});
    conn.on('open', () => {
      connectionsReverse.host = conn;
      setupConnectionHandlers(conn);
      // send join request with name
      conn.send({type:'join-request', name: myPlayerName, peerId: myPeerId});
      showJoinedArea(target);
    });
    conn.on('error', (e) => {
      alert('Không thể kết nối tới host. Mã có đúng không? Hoặc thử reload cả 2 thiết bị.\n' + (e && e));
    });
  });
}

function attachPeerEvents(){
  peer.on('open', (id) => {
    myPeerId = id;
    console.log('Peer open', id);
    if(isHost){
      // host room code is short of peer id
      roomCode = short(id);
      hostPeerId = id;
      myRoomCodeEl.textContent = roomCode;
      myRoomArea.style.display = 'block';
      lobbyPlayers.style.display = 'block';
      playersListEl.innerHTML = '';
      players = {};
      // add host as first player
      players[myPeerId] = new Bird(myPeerId, myPlayerName || 'Host', '#ffcc00');
      renderLobbyList();
      statusSmall.innerText = 'Hosting: ' + roomCode;
    } else {
      statusSmall.innerText = 'Connected: ' + short(id);
    }
  });

  // host: listen for incoming connections
  peer.on('connection', (conn) => {
    if(!isHost) return;
    const remoteId = conn.peer;
    connections[remoteId] = conn;
    conn.on('open', () => {
      setupConnectionHandlers(conn);
    });
    conn.on('close', () => {
      delete connections[remoteId];
      delete players[remoteId];
      renderLobbyList();
    });
  });

  peer.on('disconnected', ()=> { statusSmall.innerText = 'Disconnected'; });
  peer.on('error', (err)=> { console.error(err); alert('Peer error:'+err); });
}

/* short form of peer id for room code */
function short(id){
  return id ? id.slice(0,6).toUpperCase() : '';
}

/* setup handlers for a DataConnection */
function setupConnectionHandlers(conn){
  const pid = conn.peer;
  conn.on('data', (data) => {
    // handle messages
    if(isHost){
      handleHostMessage(pid, data, conn);
    } else {
      handleClientMessage(pid, data, conn);
    }
  });
  conn.on('close', ()=> {
    if(isHost){
      delete connections[pid];
      delete players[pid];
      renderLobbyList();
    } else {
      // connection to host closed
      alert('Đã mất kết nối tới host.');
      location.reload();
    }
  });
}

/* Host receives join-requests and other messages from clients */
function handleHostMessage(fromId, data, conn){
  if(!data || !data.type) return;
  if(data.type === 'join-request'){
    // add player to players list in lobby
    const name = data.name || ('P_'+ short(fromId));
    players[fromId] = new Bird(fromId, name, randomColor());
    // store metadata maybe
    renderLobbyList();
    // inform everyone that a new player joined
    messageAll({type:'player-joined', id: fromId, name: name});
  } else if(data.type === 'sync'){
    // client position update: update remote bird pos & vy
    if(players[fromId]){
      players[fromId].x = data.x;
      players[fromId].y = data.y;
      players[fromId].vy = data.vy;
      players[fromId].alive = data.alive;
      players[fromId].score = data.score;
    }
  } else if(data.type === 'reset-player'){
    // client requested reset
    if(players[fromId]){ players[fromId].alive = true; players[fromId].y = H/2; players[fromId].vy=0; }
    messageAll({type:'reset-player', id: fromId});
  } else if(data.type === 'death'){
    if(players[fromId]) players[fromId].alive = false;
    messageAll({type:'death', id: fromId});
  }
}

/* Client handles messages from host */
function handleClientMessage(fromId, data, conn){
  if(!data || !data.type) return;
  if(data.type === 'player-joined'){
    // update lobby list
    players[data.id] = new Bird(data.id, data.name, randomColor());
    renderLobbyList();
  } else if(data.type === 'lobby-list'){
    // initial list from host
    players = {};
    for(const p of data.players){
      players[p.id] = new Bird(p.id, p.name, randomColor());
    }
    renderLobbyList();
  } else if(data.type === 'start'){
    // host started game
    startGame();
  } else if(data.type === 'sync'){
    // host sending state of players (authoritative-ish)
    for(const p of data.players){
      if(p.id === myPeerId) continue; // skip local
      if(!players[p.id]) players[p.id] = new Bird(p.id, p.name, randomColor());
      players[p.id].x = p.x; players[p.id].y = p.y; players[p.id].vy = p.vy; players[p.id].alive = p.alive; players[p.id].score = p.score;
    }
  } else if(data.type === 'death'){
    if(players[data.id]) players[data.id].alive = false;
    if(data.id === myPeerId) deathScreen.style.display = 'flex';
  } else if(data.type === 'reset-player'){
    if(players[data.id]){ players[data.id].alive = true; players[data.id].y = H/2; players[data.id].vy=0; }
    if(data.id === myPeerId) deathScreen.style.display = 'none';
  }
}

/* message all connected peers (host) or message host (client) */
function messageAll(msg){
  if(isHost){
    for(const id in connections){
      try{ connections[id].send(msg); }catch(e){}
    }
    // also process locally for host view
    if(msg.type === 'start') startGame();
  } else {
    // send to host
    const c = connectionsReverse.host;
    if(c && c.open) c.send(msg);
  }
}

/* send periodic sync of local bird to host (for clients) or broadcast host authoritative state (for host) */
function sendSync(){
  if(!gameStarted) return;
  if(isHost){
    // host collects players states (host has players[] map) and broadcast
    const arr = [];
    for(const id in players){
      arr.push({id: id, name: players[id].name, x: players[id].x, y: players[id].y, vy: players[id].vy, alive: players[id].alive, score: players[id].score});
    }
    messageAll({type:'sync', players: arr});
  } else {
    // client sends its local bird state to host
    const b = players[myPeerId];
    if(!b) return;
    const c = connectionsReverse.host;
    if(c && c.open){
      c.send({type:'sync', x: b.x, y: b.y, vy: b.vy, alive: b.alive, score: b.score});
    }
  }
}

/* ---------- UI actions ---------- */

btnCreate.addEventListener('click', async () => {
  myPlayerName = (playerNameInput.value||'Player').trim() || 'Player';
  await createRoom();
  // host Peer open triggers UI
});

btnJoin.addEventListener('click', async () => {
  myPlayerName = (playerNameInput.value||'Player').trim() || 'Player';
  const code = (roomInput.value||'').trim();
  if(!code){
    alert('Nhập mã phòng (mã 6 ký tự) để join.');
    return;
  }
  // we will try connecting using the code; user should paste the host's peer id or the visible short code (short -> we try connect using short form as host id)
  await joinRoom(code);
  // show joined area will be triggered after connection open
});

function showJoinedArea(code){
  joinedRoomArea.style.display = 'block';
  joinedRoomCodeEl.textContent = code;
  lobbyPlayers.style.display = 'block';
  // add self to temporary list
  players[myPeerId] = new Bird(myPeerId, myPlayerName, randomColor());
  renderLobbyList();
}

/* Host Start */
btnStart.addEventListener('click', () => {
  if(!isHost) return;
  // send start to everyone
  messageAll({type:'start'});
  // host will also call startGame via messageAll
});

/* Host close room */
btnCloseRoom.addEventListener('click', () => {
  if(!isHost) return;
  // disconnect peers and reload
  for(const id in connections){
    try{ connections[id].close(); }catch(e){}
  }
  cleanupPeer();
  location.reload();
});

/* Reset button for local player */
btnReset.addEventListener('click', () => {
  resetLocal();
});

/* keyboard/touch input for flap */
window.addEventListener('keydown', (e) => {
  if(e.code === 'Space') {
    if(gameStarted && players[myPeerId] && players[myPeerId].alive) {
      players[myPeerId].flap();
    } else {
      // nothing
    }
  }
});
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if(gameStarted && players[myPeerId] && players[myPeerId].alive) players[myPeerId].flap();
});
canvas.addEventListener('mousedown', (e) => {
  if(gameStarted && players[myPeerId] && players[myPeerId].alive) players[myPeerId].flap();
});

/* ---------- Utility & rendering lobby list ---------- */
function renderLobbyList(){
  playersListEl.innerHTML = '';
  for(const id in players){
    const p = players[id];
    const chip = document.createElement('div');
    chip.className = 'playerChip';
    chip.textContent = (p.name || 'P') + (id === myPeerId ? ' (You)' : '');
    playersListEl.appendChild(chip);
  }
  // show lobbyPlayers
  lobbyPlayers.style.display = Object.keys(players).length ? 'block' : 'none';
}

/* random color */
function randomColor(){
  return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
}

/* cleanup peer if exists */
function cleanupPeer(){
  try{
    if(peer){
      peer.destroy();
    }
  }catch(e){}
  peer = null;
  connections = {};
  connectionsReverse = {};
  players = {};
  isHost = false;
  roomCode = null;
  hostPeerId = null;
  myPeerId = null;
}

/* ---------- When leaving page, clean up ---------- */
window.addEventListener('beforeunload', () => {
  try{ if(peer) peer.destroy(); }catch(e){}
});

/* ---------- Friendly fallback: if user creates room, show full peer id for sharing (in case short fails) ---------- */
(function exposeRoomPeerIdOnHostCreation(){
  // show full peer id if clicking the myRoomCode element
  myRoomCodeEl.addEventListener('click', () => {
    if(myPeerId) alert('Full peer id (chia sẻ nếu cần):\\n' + myPeerId);
  });
})();

/* ---------- Additional: when host gets a join request, send lobby-list to new client via their connection metadata isn't directly accessible; host will broadcast player-joined which clients use to build list. For simplicity we rely on that behavior. ---------- */

/* ---------- Small improvements: if joiner connected before host Start, show their name in host lobby (done via join-request) ---------- */

/* ---------- Boot: set default name ---------- */
playerNameInput.value = 'Player' + Math.floor(Math.random()*99);

/* ---------- Minor UI: show joinedRoomArea when we connect as joiner. We handle that in joinRoom's conn.on('open') above. ---------- */

/* ---------- Done. ---------- */
</script>
</body>
</html>
