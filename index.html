<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Flappy Birch — Multiplayer (Fix Join + Gameplay)</title>
<style>
  html,body{height:100%;margin:0;background:#87ceeb;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  #container{display:flex;flex-direction:column;height:100%;}
  header{padding:12px;background:#046; color:#fff; display:flex;align-items:center;justify-content:space-between;}
  header h1{font-size:16px;margin:0;}
  main{flex:1;display:flex;align-items:center;justify-content:center;position:relative;padding:12px;}
  .panel{width:420px;max-width:100%;background:rgba(255,255,255,0.98);border-radius:10px;padding:14px;box-shadow:0 6px 20px rgba(0,0,0,0.15);}
  label{display:block;margin-top:8px;font-size:13px;color:#333;}
  input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #ccc;box-sizing:border-box;}
  .row{display:flex;gap:8px;margin-top:8px;}
  button{flex:1;padding:10px;border-radius:8px;border:0;background:#046;color:#fff;font-weight:600;}
  button.secondary{background:#888;}
  #lobbyPlayers{margin-top:10px;font-size:13px;}
  #canvasWrap{width:100%;height:520px;max-height:70vh;background:linear-gradient(#87ceeb,#5cc1ff);border-radius:10px;overflow:hidden;position:relative;display:none;}
  canvas{display:block;width:100%;height:100%;}
  #overlay{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;pointer-events:none;}
  #deathScreen{position:absolute;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;z-index:30;background:rgba(0,0,0,0.5);}
  body,html,canvas{touch-action:manipulation; -webkit-user-select:none; user-select:none;}
  footer{padding:8px;text-align:center;font-size:12px;color:#fff;background:#034;}
  .infoSmall{font-size:12px;color:#333;margin-top:8px;}
  .fullIdBox{margin-top:8px;background:#eef;padding:8px;border-radius:8px;font-size:12px;word-break:break-all;}
</style>
</head>
<body>
<div id="container">
  <header>
    <h1>Flappy Birch — Multiplayer (Fix Join)</h1>
    <div id="statusSmall">Disconnected</div>
  </header>

  <main>
    <div class="panel" id="lobbyPanel">
      <div style="display:flex;gap:8px;align-items:center;">
        <input id="playerName" type="text" placeholder="Tên bạn (ví dụ: Quân)" />
        <button id="btnCreate">Create code</button>
      </div>

      <label>Hoặc nhập mã phòng / Full Peer ID để Join</label>
      <div class="row">
        <input id="roomInput" type="text" placeholder="Nhập mã phòng (6 ký tự) hoặc Full PeerID" />
        <button id="btnJoin" class="secondary">Join</button>
      </div>

      <div id="lobbyInfo" class="infoSmall">
        <div id="myRoomArea" style="display:none;margin-top:8px;">
          <div>Mã phòng (ngắn): <strong id="myRoomCode"></strong></div>
          <div class="fullIdBox">Full Peer ID: <span id="myFullPeerId" style="font-weight:700"></span></div>
          <div style="margin-top:8px;">
            <button id="btnCopyFull" class="secondary">Copy Full ID</button>
            <button id="btnStart">Start</button>
            <button id="btnCloseRoom" class="secondary">Close Room</button>
          </div>
          <div style="margin-top:8px;color:#555">Click "Copy Full ID" và gửi full id này cho người join nếu mã ngắn bị lỗi.</div>
        </div>

        <div id="joinedRoomArea" style="display:none;margin-top:8px;">
          <div>Bạn đã gia nhập phòng: <strong id="joinedRoomCode"></strong></div>
          <div class="small">Chờ host bấm Start...</div>
          <div style="margin-top:6px;">
            <button id="btnRetryJoin" class="secondary">Retry Join</button>
          </div>
        </div>

        <div id="lobbyPlayers" style="display:none;">
          <div>Người trong phòng:</div>
          <div id="playersList"></div>
        </div>

        <div id="joinError" style="display:none;margin-top:8px;color:#b00;"></div>
      </div>

      <div class="infoSmall" style="margin-top:10px;">
        Lưu ý: nếu bạn thấy lỗi khi nhập mã ngắn, yêu cầu host gửi <strong>Full Peer ID</strong> bằng cách bấm "Copy Full ID" rồi paste vào ô Join.
      </div>
    </div>

    <div id="canvasWrap">
      <div id="overlay"></div>
      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <div id="deathScreen">
        <div class="modal">
          <h2 style="margin:0 0 10px 0;color:#fff">Bạn đã chết</h2>
          <button id="btnReset">Reset & Play Again</button>
        </div>
      </div>
    </div>
  </main>

  <footer>Debug build — mở Console (F12) để xem log chi tiết.</footer>
</div>

<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
<script>
const $ = id => document.getElementById(id);
const btnCreate = $('btnCreate'), btnJoin = $('btnJoin'), btnStart = $('btnStart'),
      btnCloseRoom = $('btnCloseRoom'), btnCopyFull = $('btnCopyFull'), btnRetryJoin = $('btnRetryJoin'),
      btnReset = $('btnReset');
const roomInput = $('roomInput'), playerNameInput = $('playerName');
const myRoomArea = $('myRoomArea'), joinedRoomArea = $('joinedRoomArea'), myRoomCodeEl = $('myRoomCode'),
      myFullPeerIdEl = $('myFullPeerId'), joinedRoomCodeEl = $('joinedRoomCode'),
      playersListEl = $('playersList'), lobbyPlayers = $('lobbyPlayers'),
      joinErrorEl = $('joinError'), statusSmall = $('statusSmall');
let peer = null, isHost = false, myPeerId = null, roomCode = null;
let connections = {}, players = {}, connectionsReverse = {};
playerNameInput.value = 'Player' + Math.floor(Math.random()*99);

/* helpers */
function short(id){ return id ? id.slice(0,6).toUpperCase() : ''; }
function log(...a){ console.log('[APP]', ...a); }
function showError(msg){ joinErrorEl.style.display='block'; joinErrorEl.textContent = msg; }

/* ----------------------- LOBBY & PEERJS (unchanged core) ----------------------- */

/* Create room (host) */
btnCreate.addEventListener('click', async () => {
  const name = (playerNameInput.value||'Player').trim();
  if(peer) { try{ peer.destroy(); }catch(e){} }
  isHost = true;
  peer = new Peer(undefined, {secure:true, debug:2});
  peer.on('open', (id) => {
    myPeerId = id;
    roomCode = short(id);
    myRoomCodeEl.textContent = roomCode;
    myFullPeerIdEl.textContent = id;
    myRoomArea.style.display = 'block';
    lobbyPlayers.style.display = 'block';
    players = {};
    players[myPeerId] = {id: myPeerId, name: name};
    renderLobbyList();
    statusSmall.textContent = 'Hosting: ' + roomCode;
    log('Host open, id=', id);
  });
  peer.on('connection', (conn) => {
    const remote = conn.peer;
    log('Incoming conn from', remote);
    connections[remote] = conn;
    conn.on('open', () => {
      conn.on('data', (d)=> handleHostMessage(remote,d,conn));
      // send back lobby list so new client can build UI
      sendToConn(conn, {type:'lobby-list', players: Object.values(players)});
    });
    conn.on('close', ()=> {
      delete connections[remote];
      delete players[remote];
      renderLobbyList();
    });
  });
  peer.on('error', (err)=> { console.error(err); alert('Peer error: ' + err); });
});

/* Copy full id */
btnCopyFull.addEventListener('click', () => {
  const full = myFullPeerIdEl.textContent;
  if(!full) return alert('Full ID chưa sẵn sàng.');
  navigator.clipboard?.writeText(full).then(()=> alert('Full Peer ID đã copy!'), ()=> alert('Không thể copy, hãy nhấn giữ để chọn và copy thủ công.'));
});

/* Join room */
async function tryJoin(target){
  joinErrorEl.style.display = 'none';
  const name = (playerNameInput.value||'Player').trim();
  if(peer){ try{ peer.destroy(); }catch(e){} }
  isHost = false;
  peer = new Peer(undefined, {secure:true, debug:2});
  peer.on('open', () => {
    myPeerId = peer.id;
    statusSmall.textContent = 'Client ready: ' + short(myPeerId);
    attemptConnect(target, name);
  });
  peer.on('error', (err)=> {
    console.error('Peer error (client):', err);
    showError('Lỗi Peer client: ' + err);
  });
}

function attemptConnect(target, name, attempt=1){
  log('Attempt connect to', target, 'attempt', attempt);
  const conn = peer.connect(target, {metadata:{name:name}, reliable:false});
  let settled = false;
  const cleanup = ()=> {
    try{ conn.off && conn.off('error'); }catch(e){}
  };
  conn.on('open', () => {
    settled = true;
    connectionsReverse.host = conn;
    conn.on('data', (d)=> handleClientMessage(d));
    // send join request
    conn.send({type:'join-request', name: name, peerId: myPeerId});
    joinedRoomArea.style.display='block';
    joinedRoomCodeEl.textContent = target;
    renderLobbyList();
    log('Connected to host', target);
  });
  conn.on('error', (err) => {
    console.warn('Conn error to',target, err);
    if(settled) return;
    if(attempt===1){
      // second try: try uppercase / lowercase transformation of short code
      const alt = (target === target.toUpperCase()) ? target.toLowerCase() : target.toUpperCase();
      showError('Kết nối thất bại với mã ngắn. Đang thử biến thể mã... Nếu vẫn lỗi, yêu cầu host gửi Full Peer ID và dán vào ô Join.');
      setTimeout(()=> attemptConnect(alt, name, 2), 400);
    } else {
      showError('Không thể kết nối tới host bằng mã này. Hãy yêu cầu host gửi **Full Peer ID** (host bấm "Copy Full ID") và dán full id vào ô Join.');
    }
  });
  // timeout fallback
  setTimeout(()=> {
    if(!settled){
      try { conn.close(); } catch(e){}
      if(attempt===1){
        const alt = (target === target.toUpperCase()) ? target.toLowerCase() : target.toUpperCase();
        attemptConnect(alt, name, 2);
      } else {
        showError('Timeout khi cố gắng kết nối. Hãy thử dùng Full Peer ID hoặc reload cả hai thiết bị.');
      }
    }
  }, 6000);
}

btnJoin.addEventListener('click', ()=> {
  const code = (roomInput.value||'').trim();
  if(!code) return alert('Nhập mã phòng hoặc Full Peer ID để join.');
  tryJoin(code);
});
btnRetryJoin.addEventListener('click', ()=> {
  const code = (roomInput.value||'').trim();
  if(!code) return alert('Nhập mã phòng hoặc Full Peer ID để join.');
  tryJoin(code);
});

/* Host message handler (extended: handle join, client-sync, reset requests) */
function handleHostMessage(from, data, conn){
  if(!data || !data.type) return;
  if(data.type === 'join-request'){
    players[from] = {id: from, name: data.name || ('P_'+short(from))};
    log('Player join-request from', from, data.name);
    renderLobbyList();
    // broadcast join to others
    broadcast({type:'player-joined', id: from, name: players[from].name});
  } else if(data.type === 'client-sync'){
    // update host copy of remote bird and broadcast state to others
    // data.payload = {bird:{id, x,y,vy,dead,score,name,color}}
    const payload = data.payload;
    if(payload && payload.bird){
      // keep players mapping
      players[payload.bird.id] = players[payload.bird.id] || {id: payload.bird.id, name: payload.bird.name || ('P_'+short(payload.bird.id))};
      // broadcast to everyone
      broadcast({type:'state-update', state: {bird: payload.bird}});
    }
  } else if(data.type === 'request-reset'){
    // client asked to reset itself - broadcast reset to that client
    broadcast({type:'reset-player', id: from});
  }
}

/* Client message handler (extended: start, state-update, reset-player) */
function handleClientMessage(data){
  if(!data || !data.type) return;
  if(data.type === 'lobby-list'){
    players = {};
    for(const p of data.players) players[p.id] = {id:p.id, name:p.name};
    renderLobbyList();
  } else if(data.type === 'player-joined'){
    players[data.id] = {id:data.id, name:data.name};
    renderLobbyList();
  } else if(data.type === 'start'){
    // start game - now run the game
    startFlappy();
  } else if(data.type === 'state-update'){
    // host (or other peers) sent bird state; update local birds map
    const b = data.state && data.state.bird;
    if(b){
      // create or update local view of bird (do not override local player's authoritative values)
      if(!birds[b.id]) birds[b.id] = makeBirdFromState(b);
      else if(b.id !== myPeerId){
        // smooth update
        birds[b.id].x = b.x;
        birds[b.id].y = b.y;
        birds[b.id].vy = b.vy;
        birds[b.id].dead = b.dead;
        birds[b.id].score = b.score || 0;
        birds[b.id].name = b.name || birds[b.id].name;
      }
    }
  } else if(data.type === 'reset-player'){
    // host instructs reset for a player id
    if(data.id === myPeerId){
      resetLocal();
    } else {
      // reset remote bird locally too
      if(birds[data.id]) {
        birds[data.id].y = canvas.height/2;
        birds[data.id].vy = 0;
        birds[data.id].dead = false;
        birds[data.id].score = 0;
      }
    }
  }
}

/* send to a single conn (host) */
function sendToConn(conn, msg){
  try{ conn.send(msg); }catch(e){ console.warn('sendToConn failed', e); }
}

/* broadcast from host */
function broadcast(msg){
  for(const id in connections){
    try{ connections[id].send(msg); } catch(e){ console.warn('broadcast fail to', id); }
  }
}

/* UI helpers */
function renderLobbyList(){
  playersListEl.innerHTML = '';
  for(const id in players){
    const p = players[id];
    const d = document.createElement('div');
    d.textContent = (p.name || 'Player') + (id===myPeerId ? ' (You)' : '');
    d.style.padding='6px';
    d.style.background='#eef';
    d.style.margin='6px 0';
    d.style.borderRadius='6px';
    playersListEl.appendChild(d);
  }
  lobbyPlayers.style.display = Object.keys(players).length ? 'block' : 'none';
}

/* Start & close room UI handlers (host) */
btnStart.addEventListener('click', ()=> {
  if(!isHost) return;
  // notify clients to start
  broadcast({type:'start'});
  // start locally as host
  startFlappy();
});
btnCloseRoom.addEventListener('click', ()=> {
  if(peer){ try{ peer.destroy(); }catch(e){} }
  location.reload();
});

/* Reset placeholder - local reset handled in game logic now */
btnReset.addEventListener('click', ()=> { 
  // when user presses Reset, request host to reset this player (if not host), or reset locally if host
  if(isHost){
    // host resets self
    resetLocal();
    // also broadcast reset to others? keep as per request only resetting who pressed
  } else {
    // ask host to reset this player (host will broadcast reset-player)
    if(connectionsReverse.host && connectionsReverse.host.open){
      connectionsReverse.host.send({type:'request-reset'});
    }
  }
});

/* cleanup when leaving */
window.addEventListener('beforeunload', ()=> { try{ if(peer) peer.destroy(); }catch(e){} });

/* ----------------------- FLAPPY GAME (added, does not modify lobby UI) ----------------------- */

/* Canvas & game state */
const canvas = $('gameCanvas');
const ctx = canvas.getContext('2d');
const wrap = $('canvasWrap');
const deathScreen = $('deathScreen');

let birds = {}; // local view of all birds: id -> {id,name,x,y,vy,color,dead,score}
let pipes = []; // host authoritative list
let frame = 0;
let gravity = 0.4;
let flapPower = -7.5;
let pipeGap = 140;
let pipeSpawnInterval = 120; // frames
let pipeSpeed = 2.6;
let gameRunning = false;
let myBird = null;
let syncTimer = null;

/* helper to create bird object from state */
function makeBirdFromState(s){
  return {
    id: s.id,
    name: s.name || 'Player',
    x: s.x !== undefined ? s.x : 150,
    y: s.y !== undefined ? s.y : canvas.height/2,
    vy: s.vy || 0,
    color: s.color || randomColor(),
    dead: !!s.dead,
    score: s.score || 0
  };
}
function randomColor(){ return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0'); }

/* Start the Flappy game locally (called on host start or client receiving start) */
function startFlappy(){
  // hide lobby, show canvas
  $('lobbyPanel').style.display = 'none';
  wrap.style.display = 'block';
  initFlappy();
}

function initFlappy(){
  // initialize pipes and birds
  pipes = [];
  frame = 0;
  birds = {};
  // create local player's bird
  myBird = {
    id: myPeerId,
    name: players[myPeerId] ? players[myPeerId].name : (playerNameInput.value || 'You'),
    x: 150,
    y: canvas.height/2,
    vy: 0,
    color: isHost ? '#ffcc00' : randomColor(),
    dead: false,
    score: 0
  };
  birds[myPeerId] = myBird;
  // if host, add other players from players map (they will sync in)
  for(const id in players){
    if(id === myPeerId) continue;
    birds[id] = makeBirdFromState({id: id, name: players[id].name || ('P_'+short(id)), x: 150, y: canvas.height/2, color: randomColor(), dead: false, score:0});
  }
  gameRunning = true;
  deathScreen.style.display = 'none';
  // host authoritative loop: physics + broadcast
  if(syncTimer) clearInterval(syncTimer);
  syncTimer = setInterval(() => {
    if(isHost) hostTick();
    else clientTick();
  }, 1000/60);
  requestAnimationFrame(renderLoop);
}

/* Host tick: update pipes, birds physics, handle collisions, broadcast state to clients */
function hostTick(){
  frame++;
  // spawn pipes
  if(frame % pipeSpawnInterval === 0){
    const top = Math.floor(Math.random()*(canvas.height - 200 - pipeGap)) + 60;
    pipes.push({x: canvas.width + 40, top: top, gap: pipeGap, passedIds: {}});
  }
  // move pipes
  for(const p of pipes) p.x -= pipeSpeed;
  // remove offscreen
  if(pipes.length && pipes[0].x < -100) pipes.shift();

  // update birds physics and scoring
  for(const id in birds){
    const b = birds[id];
    if(!b || b.dead) continue;
    b.vy += gravity;
    b.y += b.vy;
    // ground/ceiling
    if(b.y + 12 >= canvas.height - 50){ b.dead = true; if(id === myPeerId) onDieLocal(); }
    if(b.y - 12 <= 0){ b.y = 12; b.vy = 0; }
    // pipe collisions & scoring
    for(const p of pipes){
      if(b.x + 12 > p.x && b.x - 12 < p.x + 52){
        if(b.y - 12 < p.top || b.y + 12 > p.top + p.gap){
          b.dead = true;
          if(id === myPeerId) onDieLocal();
        }
      } else {
        // scoring: when bird passes pipe's trailing edge
        if(!p.passedIds[id] && b.x > p.x + 52){
          p.passedIds[id] = true;
          b.score = (b.score || 0) + 1;
        }
      }
    }
  }

  // broadcast host authoritative state: pipes + birds minimal info
  const birdsArray = [];
  for(const id in birds){
    const b = birds[id];
    birdsArray.push({id: b.id, x: b.x, y: b.y, vy: b.vy, dead: b.dead, score: b.score, name: b.name, color: b.color});
  }
  const payload = {type: 'host-state', pipes: pipes.map(p => ({x:p.x, top:p.top, gap:p.gap, passedIds:p.passedIds})), birds: birdsArray};
  // host sends to all clients
  broadcast(payload);
}

/* Client tick: send own bird state to host (lightweight), host will broadcast authoritative state */
function clientTick(){
  // update local bird physics (client predicts own movement)
  if(myBird && !myBird.dead){
    myBird.vy += gravity;
    myBird.y += myBird.vy;
    if(myBird.y + 12 >= canvas.height - 50){ myBird.dead = true; onDieLocal(); }
    if(myBird.y - 12 <= 0){ myBird.y = 12; myBird.vy = 0; }
    // send lightweight sync to host
    if(connectionsReverse.host && connectionsReverse.host.open){
      connectionsReverse.host.send({type: 'client-sync', payload: {bird: {id: myBird.id, x: myBird.x, y: myBird.y, vy: myBird.vy, dead: myBird.dead, score: myBird.score, name: myBird.name, color: myBird.color}}});
    }
  }
}

/* Render loop: draw pipes and birds */
function renderLoop(){
  // draw background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // sky
  ctx.fillStyle = '#87ceeb';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // ground
  ctx.fillStyle = '#6b3';
  ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
  // pipes
  ctx.fillStyle = '#2b8';
  for(const p of pipes){
    ctx.fillRect(p.x, 0, 52, p.top);
    ctx.fillRect(p.x, p.top + p.gap, 52, canvas.height - (p.top + p.gap) - 50);
  }
  // birds
  for(const id in birds){
    const b = birds[id];
    if(!b) continue;
    ctx.fillStyle = b.color || '#ff0';
    ctx.beginPath();
    ctx.ellipse(b.x, b.y, 12, 10, 0, 0, Math.PI*2);
    ctx.fill();
    // eye
    ctx.fillStyle = '#000';
    ctx.fillRect(b.x + 4, b.y - 3, 3, 3);
    // name + score
    ctx.fillStyle = '#000';
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`${b.name || 'Player'} (${b.score || 0})`, b.x, b.y - 18);
  }

  if(gameRunning) requestAnimationFrame(renderLoop);
}

/* Input handling (flap) */
function flapLocal(){
  if(!myBird || myBird.dead) return;
  myBird.vy = flapPower;
  // for host, immediate effect; for client, will be sent during clientTick
  if(isHost){
    // nothing extra: hostTick will include updated myBird
  }
}
canvas.addEventListener('mousedown', (e)=> { flapLocal(); });
canvas.addEventListener('touchstart', (e)=> { e.preventDefault(); flapLocal(); }, {passive:false});
window.addEventListener('keydown', (e)=> { if(e.code === 'Space') flapLocal(); });

/* When local player dies: stop local game loop and show death screen */
function onDieLocal(){
  // stop sending updates for this player
  // gameRunning for host continues (host still processes other birds), but for local player we show death screen and prevent flapping
  gameRunning = isHost ? true : false; // host keeps running to manage others; client stops rendering updates (but still receives host-state)
  if(!isHost) {
    // client stops own local physics ticks (handled by myBird.dead flag)
  }
  deathScreen.style.display = 'flex';
}

/* Reset local player (respawn) */
function resetLocal(){
  if(!myBird) return;
  myBird.y = canvas.height/2;
  myBird.vy = 0;
  myBird.dead = false;
  myBird.score = 0;
  deathScreen.style.display = 'none';
  // tell host to reset this player if client
  if(!isHost && connectionsReverse.host && connectionsReverse.host.open){
    connectionsReverse.host.send({type:'reset-player-request', id: myPeerId});
  }
  // if host, also reset own and broadcast
  if(isHost){
    // reset bird in host birds map
    if(birds[myPeerId]){
      birds[myPeerId].y = canvas.height/2;
      birds[myPeerId].vy = 0;
      birds[myPeerId].dead = false;
      birds[myPeerId].score = 0;
    }
    // broadcast reset to others
    broadcast({type:'reset-player', id: myPeerId});
  }
}

/* Handling incoming host-state messages when client */
function processHostState(state){
  if(!state) return;
  // update pipes
  if(state.pipes) pipes = state.pipes.map(p => ({x:p.x, top:p.top, gap:p.gap, passedIds: p.passedIds || {}}));
  // update birds
  if(state.birds){
    for(const b of state.birds){
      if(b.id === myPeerId){
        // if local player: update score and dead flag but keep local physics for client prediction
        if(myBird){
          myBird.score = b.score || myBird.score;
          myBird.dead = b.dead || myBird.dead;
          if(myBird.dead) onDieLocal();
        }
      } else {
        birds[b.id] = makeBirdFromState(b);
      }
    }
  }
}

/* Wire host-state messages coming via PeerJS: extend handleClientMessage & handleHostMessage already handle 'state-update' above.
   But we also need to intercept direct messages (some peers send host-state payload) — handle in connection on('data') already calls respective handlers. */

/* When client receives 'host-state' (hostTick broadcast), handleClientMessage will receive state-update and we process it there.
   To be safe, intercept connectionsReverse.host data events in tryJoin (already set handleClientMessage). */

/* Hook into broadcast/receive: modify handleClientMessage to accept 'host-state' if present (already 'state-update' used).
   But to ensure we catch host-state, also treat data.type==='host-state' -> call processHostState.
*/
const originalHandleClientMessage = handleClientMessage;
handleClientMessage = function(data){
  if(!data || !data.type){
    // may be host-state if full payload
    if(data && data.birds && data.pipes){
      processHostState(data);
      return;
    }
    return;
  }
  if(data.type === 'host-state'){
    processHostState(data);
    return;
  }
  // call original for other types
  originalHandleClientMessage(data);
};

/* When host receives client sync messages earlier we broadcast state-update; but host will also send full 'host-state' at hostTick using broadcast(payload) */

/* Also ensure broadcast() sends raw objects; clients will receive and process host-state above */

/* Clean up on unload */
window.addEventListener('beforeunload', () => {
  if(syncTimer) clearInterval(syncTimer);
});

/* End of game additions */

</script>
</body>
</html>
